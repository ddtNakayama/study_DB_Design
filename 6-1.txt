
■ビットマップインデックス

	値の一覧に対して一致、不一致しているかの情報をビットのマップで管理するもの。
	
	例）ユーザ
		ID,名前,血液型,性別
		 1,佐藤,     A,  男
		 2,鈴木,     B,  女
		 3,田中,     O,  男
		 4,高橋,     A,  女
		 5,伊藤,     O,  男
		 6,山本,    AB,  女
		 
		 このとき、血液型のビットマップは以下となる。
		 
		 A: 1,0,0,1,0,0
		 B: 0,1,0,0,0,0
		AB: 0,0,1,0,1,0
		 O: 0,0,0,0,0,1
	
	■長所
			 
	①カーディナリティが低い列に対して有効
		
		一般的なインデックスのB-Treeインデックスはカーディナリティが高い列に対して有効。
		
		※カーディナリティ：取る値の種類の数のこと
			「名前」列があったとすると、それはカーディナリティが高い（同名はあまりないため）
			「血液型」列があったとすると、それはカーディナリティが低い（A、B、AB、Oの４種類しかないため）
		
	②インデックスを設定した列に対して、ＯＲを使用してもインデックスが適用される
	
		B-Treeインデックスでは、インデックスを設定した列にたいしてＯＲを使用するとインデックスが適用されない。
		対して、ビットマップインデックスでは適用される。上記の例の結果から論理和をとるだけで対象を選別できる。
	
	■短所
	
	①ビットマップの更新にはロックが発生する。
	　そのため、値の更新が多い列に設定すると、待機待ちが発生して時間がかかる恐れがある。
	
■ハッシュインデックス

	B-Treeインデックスは木構造で管理している。これは、値の大小で繰り返し分岐して対象の値にたどり着く方式だが、ハッシュインデックスでは１回の判定で対象の値にたどり着ける。
	⇒各値に対してハッシュ値を生成し、そのハッシュ値と一致するものを取得することで、一回だけの判定を実現する。
	
	■長所
	
	①きわめて高速
		
		上述の通り、一回の判定で対象を指定できるため。
	
	■短所
	
	①一致検索でしか使用できない
	
		ハッシュ値が一致するかでしかないため、比較演算子による検索には使用できない。
	
	②ソート処理（ORDER BY）の高速化はできない
	
		B-Treeインデックスはソート処理の高速化ができるのに対し、ハッシュインデックスはできない。